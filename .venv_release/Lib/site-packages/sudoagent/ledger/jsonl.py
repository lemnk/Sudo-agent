"""Append-only JSONL ledger with canonical hashing and locking."""

from __future__ import annotations

import copy
import json
import os
from contextlib import contextmanager
from dataclasses import dataclass
from decimal import Decimal
from pathlib import Path
from typing import Any, Iterator, Protocol, TextIO, TypeAlias, cast

from sudoagent.ledger.canonical import (
    CanonicalizationError,
    canonical_dumps,
    canonical_sha256_hex,
)
from sudoagent.ledger.signing import sign_entry_hash, verify_entry_hash
from sudoagent.ledger.versioning import LEDGER_VERSION, SCHEMA_VERSION

JSONPrimitive: TypeAlias = str | int | bool | None | Decimal
JSONNumber: TypeAlias = str | int | Decimal
JSONValue: TypeAlias = (
    JSONPrimitive | JSONNumber | dict[str, "JSONValue"] | list["JSONValue"]
)
SigningKey: TypeAlias = Any  # one-line justification: optional dependency at runtime
VerifyKey: TypeAlias = Any  # one-line justification: optional dependency at runtime


class LedgerError(RuntimeError):
    """Base class for ledger errors."""


class LedgerWriteError(LedgerError):
    """Raised when an append operation fails."""


class LedgerVerificationError(LedgerError):
    """Raised when ledger verification fails."""


@dataclass(frozen=True)
class JSONLLedger:
    path: Path
    signing_key: SigningKey | None = None

    def append(self, entry: dict[str, JSONValue]) -> str:
        """Append an entry, computing chain hashes atomically."""
        try:
            self.path.parent.mkdir(parents=True, exist_ok=True)
            with _locked_file(self.path) as handle:
                last_hash = _read_last_entry_hash(handle)
                prepared = _prepare_entry(entry, last_hash)
                entry_hash = prepared.get("entry_hash")
                if not isinstance(entry_hash, str):
                    raise LedgerWriteError("entry_hash missing after preparation")
                if self.signing_key is not None:
                    prepared["entry_signature"] = sign_entry_hash(self.signing_key, entry_hash)
                line = canonical_dumps(prepared)
                handle.seek(0, os.SEEK_END)
                handle.write(line + "\n")
                handle.flush()
                os.fsync(handle.fileno())
                return entry_hash
        except (OSError, CanonicalizationError, LedgerError) as exc:
            raise LedgerWriteError(str(exc)) from exc

    def verify(self, *, public_key: VerifyKey | None = None) -> None:
        """Verify the entire ledger, failing on any tamper, gap, or reordering."""
        try:
            if not self.path.exists():
                return
            with _locked_file(self.path) as handle:
                _verify_stream(handle, public_key=public_key)
        except (OSError, CanonicalizationError, LedgerError, json.JSONDecodeError) as exc:
            raise LedgerVerificationError(str(exc)) from exc


@contextmanager
def _locked_file(path: Path) -> Iterator[TextIO]:
    path.parent.mkdir(parents=True, exist_ok=True)
    file_handle = path.open("a+", encoding="utf-8", newline="")
    try:
        file_handle.seek(0)
        _lock(file_handle)
        file_handle.seek(0)
        yield file_handle
    finally:
        try:
            file_handle.seek(0)
            _unlock(file_handle)
        finally:
            file_handle.close()


def _lock(file_handle: TextIO) -> None:
    if os.name == "nt":
        import msvcrt

        msvcrt.locking(file_handle.fileno(), msvcrt.LK_LOCK, _LOCK_LENGTH)
    else:
        import fcntl

        fcntl_mod = cast(_FcntlModule, fcntl)
        fcntl_mod.flock(file_handle.fileno(), fcntl_mod.LOCK_EX)


def _unlock(file_handle: TextIO) -> None:
    if os.name == "nt":
        import msvcrt

        msvcrt.locking(file_handle.fileno(), msvcrt.LK_UNLCK, _LOCK_LENGTH)
    else:
        import fcntl

        fcntl_mod = cast(_FcntlModule, fcntl)
        fcntl_mod.flock(file_handle.fileno(), fcntl_mod.LOCK_UN)


_LOCK_LENGTH = 1


class _FcntlModule(Protocol):
    # typing shim for mypy on Windows (fcntl types missing on nt)
    LOCK_EX: int
    LOCK_UN: int

    def flock(self, fd: int, operation: int) -> None:
        ...


def _prepare_entry(entry: dict[str, JSONValue], prev_hash: str | None) -> dict[str, JSONValue]:
    candidate = copy.deepcopy(entry)
    candidate["prev_entry_hash"] = prev_hash
    candidate["entry_hash"] = None
    entry_hash = canonical_sha256_hex(candidate)
    candidate["entry_hash"] = entry_hash
    return candidate


def _read_last_entry_hash(handle: TextIO) -> str | None:
    handle.seek(0)
    last_line = None
    for line in handle:
        if line.strip():
            last_line = line.rstrip("\n")
    if last_line is None:
        return None
    last_entry = json.loads(last_line, parse_float=Decimal, parse_int=int)
    if not isinstance(last_entry, dict):
        raise LedgerVerificationError("ledger line is not an object")
    entry_hash = last_entry.get("entry_hash")
    if not isinstance(entry_hash, str):
        raise LedgerVerificationError("entry_hash missing or invalid")
    return entry_hash


def _verify_stream(handle: TextIO, *, public_key: VerifyKey | None = None) -> None:
    expected_prev: str | None = None
    decision_hashes: dict[str, str] = {}
    line_number = 0
    for raw_line in handle:
        line_number += 1
        line = raw_line.rstrip("\n")
        if not line:
            raise LedgerVerificationError(f"empty line at {line_number}")
        entry = json.loads(line, parse_float=Decimal, parse_int=int)
        if not isinstance(entry, dict):
            raise LedgerVerificationError(f"line {line_number} is not an object")
        if canonical_dumps(entry) != line:
            raise LedgerVerificationError(f"line {line_number} is not canonical")

        schema_version = entry.get("schema_version")
        if schema_version != SCHEMA_VERSION:
            raise LedgerVerificationError(f"schema_version mismatch at line {line_number}")
        ledger_version = entry.get("ledger_version")
        if ledger_version != LEDGER_VERSION:
            raise LedgerVerificationError(f"ledger_version mismatch at line {line_number}")

        request_id = entry.get("request_id")
        if not isinstance(request_id, str):
            raise LedgerVerificationError(f"request_id missing at line {line_number}")
        event = entry.get("event")
        if event not in ("decision", "outcome"):
            raise LedgerVerificationError(f"event type invalid at line {line_number}")
        decision_block = entry.get("decision")
        if not isinstance(decision_block, dict):
            raise LedgerVerificationError(f"decision block missing at line {line_number}")
        decision_hash_value = decision_block.get("decision_hash")
        if event == "decision":
            if not isinstance(decision_hash_value, str):
                raise LedgerVerificationError(f"decision_hash missing at line {line_number}")
            if decision_hash_value in decision_hashes:
                raise LedgerVerificationError(f"duplicate decision_hash at line {line_number}")
            decision_hashes[decision_hash_value] = request_id
        else:
            if not isinstance(decision_hash_value, str):
                raise LedgerVerificationError(f"decision_hash missing at line {line_number}")
            if decision_hash_value not in decision_hashes:
                raise LedgerVerificationError(f"decision_hash unknown at line {line_number}")
            if decision_hashes[decision_hash_value] != request_id:
                raise LedgerVerificationError(f"decision_hash mismatch at line {line_number}")

        prev_hash = entry.get("prev_entry_hash")
        if prev_hash is not None and not isinstance(prev_hash, str):
            raise LedgerVerificationError(f"prev_entry_hash type invalid at line {line_number}")
        if prev_hash != expected_prev:
            raise LedgerVerificationError(f"prev_entry_hash mismatch at line {line_number}")

        entry_with_null = copy.deepcopy(entry)
        entry_with_null["entry_hash"] = None
        if "entry_signature" in entry_with_null:
            entry_with_null["entry_signature"] = None
        calculated_hash = canonical_sha256_hex(entry_with_null)

        actual_hash = entry.get("entry_hash")
        if not isinstance(actual_hash, str):
            raise LedgerVerificationError(f"entry_hash missing at line {line_number}")
        if calculated_hash != actual_hash:
            raise LedgerVerificationError(f"entry_hash mismatch at line {line_number}")

        if public_key is not None:
            signature = entry.get("entry_signature")
            if not isinstance(signature, str):
                raise LedgerVerificationError(f"entry_signature missing at line {line_number}")
            if not verify_entry_hash(public_key, actual_hash, signature):
                raise LedgerVerificationError(f"entry_signature invalid at line {line_number}")

        expected_prev = actual_hash
    # if file empty, nothing to do
